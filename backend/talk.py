# -*- coding: utf-8 -*-
"""HackathonNotebookTemplate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Sl5vTKhm04MRlnOzg3HNDWy9O3tWxy6t

<span style="color:darkolivegreen;font-weight:800;font-size:32px">
    Building Agentic Apps: ArangoDB, NVIDIA cuGraph, and NetworkX Hackathon
</span>

<br>

<p align="center">
    <img src="https://arangodb.com/wp-content/uploads/2016/05/ArangoDB_logo_avocado_@1.png" style="height: 50px;">
    <img src="https://www.nvidia.com/content/dam/en-zz/Solutions/about-nvidia/logo-and-brand/02-nvidia-logo-color-grn-500x200-4c25-p@2x.png" style="height: 50px;">
    <img src="https://rapids.ai/images/RAPIDS-logo.png" style="height: 50px;">
    <img src="https://avatars.githubusercontent.com/u/388785?s=200&v=4" style="height: 50px;">
</p>

# Overview

Imagine competing in a high-stakes hackathon where the cutting edge of AI - Agentic Applications, GraphRAG, and NVIDIA cuGraph GPU-accelerated graph analytics - converge to redefine the future of GenAI-powered business solutions. With GraphRAG emerging as the most advanced Retrieval-Augmented Generation (RAG) approach, this competition challenges you to develop an intelligent agent that can query and reason over graph data with precision and efficiency.

### **Why GraphRAG**?
Traditional RAG systems rely solely on vector-based retrieval, which can lead to hallucinations, context fragmentation, and a lack of structured reasoning. GraphRAG addresses these shortcomings by integrating graph-based retrieval, preserving contextual relationships between entities and enabling more accurate, structured, and interpretable AI-generated responses.  
By leveraging GraphRAG, participants can minimize hallucinations, improve knowledge retrieval, and enhance AI-generated insights—a fundamental breakthrough for enterprises using generative AI in business-critical applications.

### **Your Mission**
Build an Agentic Application that integrates GraphRAG and GPU-accelerated graph analytics to solve a real-world problem.  
Participants have two dataset options:
- **Bring Your Own Data (BYOD)** – Select an open dataset relevant to your use case.
- **Use ArangoDB's Provided Dataset** – A pre-configured dataset optimized for graph analytics and GraphRAG tasks.

To streamline development, ArangoDB will provide a sample Jupyter Notebook with pre-built placeholders to help structure each step of the process.

# Context

### **ArangoDB & NVIDIA**

[**ArangoDB**](https://arangodb.com/) is a multi-model, open-source NoSQL database that supports graph, document, and key-value data models within a single database engine. This flexibility enables developers to handle complex, interconnected data with ease, as opposed to traditional databases that might require multiple systems for different data types. ArangoDB is designed to provide scalability, reliability, and speed, and is commonly used for applications requiring real-time analytics, social networks, recommendation engines, and other data-intensive workloads.

**Key Features of ArangoDB**

1. **Multi-Model Approach**:
   - ArangoDB supports different data models: Document (similar to MongoDB), Graph (similar to Neo4j), Search (similar to ElasticSearch), and (most recently) Vector (similar to FAISS). This multi-model approach allows developers to choose the best model for different parts of their application without needing to integrate multiple databases.

2. **AQL (Arango Query Language)**:
   - ArangoDB uses its own query language, AQL, which is similar to SQL but tailored for its multi-model structure. It supports complex queries across graphs, documents, and key-value stores, simplifying development and reducing the need for complex joins between different data stores.

3. **Horizontal Scaling**:
   - ArangoDB supports sharding, replication, and distributed deployments, ensuring that applications can scale horizontally, distributing data across multiple servers while maintaining high availability.

4. **ACID Transactions**:
   - Unlike some NoSQL databases, ArangoDB offers ACID-compliant transactions, making it suitable for applications requiring strong consistency and reliability.

5. **Graph Processing**:
   - The graph database model is particularly useful for applications that need to process relationships between entities, such as social media platforms, fraud detection systems, or knowledge graphs.

**Relationship with NVIDIA**

The close relationship between **ArangoDB** and **NVIDIA** stems from the increasing need for high-performance data processing, particularly in graph analytics and AI-related workloads. NVIDIA, known for its leadership in GPU technologies, provides the computational power necessary to accelerate certain database operations, especially those related to complex analytics.

Key Points in the relationship:

1. **GPU Acceleration for Graph Processing**:
   - Graph analytics is a computationally intensive task, and the parallel processing power of NVIDIA GPUs can significantly speed up graph-related queries. ArangoDB has explored integrating GPU acceleration for graph queries and other high-performance data processing tasks, which helps in reducing the time required to analyze complex networks of data.

2. **AI/ML Integration**:
   - With the rise of AI and machine learning, ArangoDB's ability to handle multi-model data is crucial. NVIDIA's technologies, such as GPUs and CUDA (Compute Unified Device Architecture), can accelerate machine learning models and data pipelines that interact with ArangoDB, improving overall performance and enabling real-time analytics for AI-based applications.

3. **Collaborative Projects**:
   - NVIDIA and ArangoDB have explored joint initiatives to enhance the database's performance, particularly in the context of graph-based machine learning and AI research. This includes optimizing database queries and enabling more efficient data processing workflows, which can be crucial for industries like finance, healthcare, and autonomous driving.

### **NetworkX & cuGraph**

NetworkX is a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks. It provides:
* tools for the study of the structure and dynamics of social, biological, and infrastructure networks;
* a standard programming interface and graph implementation that is suitable for many applications;
* a rapid development environment for collaborative, multidisciplinary projects;
* an interface to existing numerical algorithms and code written in C, C++, and FORTRAN; and
* the ability to painlessly work with large nonstandard data sets.

With NetworkX you can load and store networks in standard and nonstandard data formats, generate many types of random and classic networks, analyze network structure, build network models, design new network algorithms, draw networks, and much more.

While NetworkX provides a tremendous amount of usability right out of the box, **performance and scalability for medium-to-large-sized networks are far from best-in-class and can significantly limit a data scientist's productivity**.

The **RAPIDS cuGraph** project was created to bridge the gap between fast, scalable, **GPU-based graph analytics** and NetworkX ease-of-use.

cuGraph was designed with NetworkX interoperability in mind, which can be seen when you replace only the `betweenness_centrality` call from the prior example with cuGraph's `betweenness_centrality` and leave the rest of the code as-is.

**Meanwhile, NetworkX adds dispatching to [backends](https://networkx.org/documentation/stable/backends.html)…**

NetworkX has recently added the ability to dispatch API calls to different analytic backends provided by third parties. These backends can provide alternate implementations for various NetworkX APIs that can greatly improve performance.

By enabling other graph libraries to easily extend NetworkX through backends, NetworkX becomes a standard graph analytics frontend.  This means more users can use the capabilities of other graph libraries without the learning curve and integration time associated with a new library.

Library maintainers also benefit from NetworkX dispatching because they can reach more users without the overhead of maintaining a user-facing API. Instead, they can just focus on delivering a backend.

And thus the first NetworkX GPU Backend was released: [nx-cugraph](https://docs.rapids.ai/api/cugraph/nightly/nx_cugraph/nx_cugraph/)

**However, NetworKX remains in-memory only...**

The opportunity to introduce a **Persistence Backend** was presented to ArangoDB via our parternship with NVIDIA, resulting in the release of `nx-arangodb`, and a Developer Blog Post published by NVIDIA: https://developer.nvidia.com/blog/accelerated-production-ready-graph-analytics-for-networkx-users/

<p align="center">
    <img src="attachment:b5af8b9d-6ec3-4eba-a73d-934ea6f1439c.png" style="height: 500px;">
</p>

#### **NetworkX-ArangoDB**

`nx-arangodb` is a [backend to NetworkX](https://networkx.org/documentation/stable/reference/backends.html) that offers [ArangoDB](https://github.com/arangodb/arangodb) as a [Persistence Layer to NetworkX Graphs](https://arangodb.com/introducing-the-arangodb-networkx-persistence-layer/):
1. Persist NetworkX Graphs to ArangoDB.
2. Reload NetworkX Graphs from ArangoDB.
2. Perform CRUD on ArangoDB Graphs via NetworkX.
3. Run algorithms (CPU & GPU) on ArangoDB Graphs via NetworkX.

Benefits of having ArangoDB as a backend to NetworkX include:
1. No need to re-create the graph every time you start a new session.
2. Access to GPU-accelerated graph analytics ([nx-cugraph](https://rapids.ai/nx-cugraph/)).
3. Access to a database query language ([Arango Query Language](https://arangodb.com/sql-aql-comparison/)).
4. Access to a visual interface for graph exploration ([ArangoDB Web UI](https://docs.arangodb.com/stable/components/web-interface/graphs/)).
5. Access to cross-collaboration on the same graph ([ArangoDB Cloud](https://docs.arangodb.com/stable/get-started/set-up-a-cloud-instance/)).
6. Access to efficient distribution of graph data ([ArangoDB SmartGraphs](https://docs.arangodb.com/stable/graphs/smartgraphs/)).

Additional Documentation:
- [NetworkX Hello World](https://networkx.org/documentation/stable/tutorial.html)
- [nx-cugraph](https://docs.rapids.ai/api/cugraph/nightly/nx_cugraph/nx_cugraph/)


<p align="center">
    <img src="https://raw.githubusercontent.com/arangodb/nx-arangodb/main/doc/_static/nxadb.png" style="height: 200px;">
    <img src="https://raw.githubusercontent.com/arangodb/nx-arangodb/main/doc/_static/dispatch.png" style="height: 200px;">
</p>

# Template

**For demo purposes, this Notebook Template will use the [Social Circle dataset from SNAP](https://snap.stanford.edu/data/ego-Facebook.html) to provide a walk-through of the expected Hackathon Submission for attendees.**

This facebook network is undirected and has no weights because one user can become friends with another user just once. Looking at the dataset from a graph analysis perspective:
- Each node represents an anonymized facebook user that belongs to one of those ten friends lists.
- Each edge corresponds to the friendship of two facebook users that belong to this network. In other words, two users must become friends on facebook in order for them to be connected in the particular network.

**Note that this dataset is not permitted to be used for submission purposes, it is only meant to be shown as an example.**

### Step 0: Package Installation & setup
"""

# 1. Install nx-arangodb via pip
# Github: https://github.com/arangodb/nx-arangodb

# 2. Check if you have an NVIDIA GPU
# Note: If this returns "command not found", then GPU-based algorithms via cuGraph are unavailable


# 3. Install nx-cugraph via pip
# Note: Only enable this installation if the step above is working!


# 4. Install LangChain & LangGraph

# 5. Import the required modules

import networkx as nx
import nx_arangodb as nxadb

from arango import ArangoClient

import pandas as pd
import numpy as np
from random import randint
import re
import matplotlib.pyplot as plt

from langgraph.prebuilt import create_react_agent
from langgraph.checkpoint.memory import MemorySaver
from langchain_openai import ChatOpenAI
from langchain_community.graphs import ArangoGraph
from langchain_community.chains.graph_qa.arangodb import ArangoGraphQAChain
from langchain_core.tools import tool

# 6. Connect to the ArangoDB database
# TODO: Configure your credentials here!

db = ArangoClient(hosts="http://localhost:8529").db(username="root", password="zxcv", verify=True)

print(db)

"""### Step 1: Choose & prepare your dataset for NetworkX

This section will provide a template for data transformation, including placeholders for loading CSV/JSON files, defining graph schemas, and preparing data for ingestion.
"""

# 1. Download the dataset
# Reference: https://snap.stanford.edu/data/ego-Facebook.html
# Reference: https://networkx.org/nx-guides/content/exploratory_notebooks/facebook_notebook.html#facebook-network-analysis


# 2. Load the dataset into a CSV
# Reference: https://networkx.org/nx-guides/content/exploratory_notebooks/facebook_notebook.html#analysis
# Reference: https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html

facebook = pd.read_csv(
    "./facebook_combined.txt.gz",
    compression="gzip",
    sep=" ",
    names=["start_node", "end_node"],
)

facebook

"""### Step 2: Convert and Load Graph Data into NetworkX

This section will include placeholders for defining graph nodes, edges, and visualizing small test datasets before full ingestion.

Although we are creating a NetworkX Graph from a Pandas Edgelist in this example, there many other ways you can load data into NetworkX.

For more information about this, refer to the following documentation: https://networkx.org/documentation/stable/reference/convert.html
"""

# 1. Load the dataset a NetworkX Graph
# Reference: https://networkx.org/documentation/stable/reference/generated/networkx.convert_matrix.from_pandas_edgelist.html

G = nx.from_pandas_edgelist(facebook, "start_node", "end_node")

print(G)

# 2. Print the degree of one of the nodes

print(G.degree(107))

# 3. Visualize the Graph
# Reference: https://networkx.org/nx-guides/content/exploratory_notebooks/facebook_notebook.html#visualizing-the-graph

plot_options = {"node_size": 10, "with_labels": False, "width": 0.15}
pos = nx.spring_layout(G, iterations=15, seed=1721)
fig, ax = plt.subplots(figsize=(15, 9))
nx.draw_networkx(G, pos=pos, ax=ax, **plot_options)

"""### Step 3: Persist the Graph in ArangoDB

This section will include pre-written code templates for interacting with ArangoDB, making it easier for participants to insert and query their data.

For this new [nxadb.Graph()](https://nx-arangodb.readthedocs.io/en/latest/classes/graph.html) object, we will pass `name="Facebook"`, `db=db`, and `incoming_graph_data=G_nx`. This last parameter allows us to load the NetworkX Graph directly into ArangoDB:
"""

# 1. Load the NetworkX Graph into ArangoDB
# Reference: https://github.com/arangodb/nx-arangodb?tab=readme-ov-file#can-i-create-an-arangodb-graph-from-an-existing-networkx-graph

G_adb = nxadb.Graph(
    name="Facebook",
    db=db,
    incoming_graph_data=G,
    write_batch_size=50000, # feel free to modify
    overwrite_graph=True
)

print(G_adb)

"""Great! We've created our first [nxadb.Graph()](https://nx-arangodb.readthedocs.io/en/latest/classes/graph.html) object.

Note that there are [4 Graph Types](https://networkx.org/documentation/stable/reference/classes/index.html) in NetworkX, which are also supported as [nxadb Graphs](https://nx-arangodb.readthedocs.io/en/latest/classes/index.html):

1. `nxadb.Graph`: This class implements an undirected graph. It ignores multiple edges between two nodes. It does allow self-loop edges between a node and itself.
2. `nxadb.DiGraph`: Directed graphs, that is, graphs with directed edges. Provides operations common to directed graphs, (a subclass of Graph).
3. `nxadb.MultiGraph`: A flexible graph class that allows multiple undirected edges between pairs of nodes. The additional flexibility leads to some degradation in performance, though usually not significant.
4. `nxadb.MultiDiGraph`: A directed version of a MultiGraph.

Let's continue with the same Graph for now, and re-instantiate the `G_adb` object to showcase the persistence factor!
"""

# 2. Re-connect to the same Graph

G_adb = nxadb.Graph(name="Facebook", db=db)

print(G_adb)

"""Feel free to take a moment to view the created graph in ArangoDB:

1. Log into your deployment with username `root` and your designated password.
2. Select your database (most likely `_system`)
3. Navigate to the `GRAPHS` tab (selectable on the left-hand side after login)
4. Click on your graph (in this example, it would be called `Facebook`)
5. Experiment with the visualizer options to learn more about your Graph

For example, here's a quick sample of our `Facebook` graph:

<p align="center">
    <img src="attachment:54d53cbe-c3b4-407a-9acf-b141c561f14f.png" style="height: 400px;">
</p>
"""

# 3. Print the degree of a Node

G_adb.degree(107)

# 4. Query the Graph
# Reference: https://arangodb.com/sql-aql-comparison/

# Sample 3 nodes
result = G_adb.query("""
    FOR node IN Facebook_node
        SORT RAND()
        LIMIT 3
        RETURN node
""")

print(list(result))
print('-'*10)

# Sample 3 edges
result = G_adb.query("""
    FOR edge IN Facebook_node_to_Facebook_node
        SORT RAND()
        LIMIT 3
        RETURN edge
""")

print(list(result))
print('-'*10)

# Traverse a node's 1-hop neighborhood
result = G_adb.query("""
    FOR node, edge, path IN 1..1 ANY 'Facebook_node/1' GRAPH Facebook
        LIMIT 1
        RETURN path
""")

print(list(result))

"""Final note: Heterogeneous Graphs in NetworkX aren't "officially" distinguished from Homogenous NetworkX Graphs. NetworkX **does not** provide a structured way to distinguish between different Node Types or Edge Types. It is up to the NetworKX user to define *how* they want to make this distinction.

In the case of NetworkX-ArangoDB, we choose to support Heteregeneous Graphs via the `_id` field, which allows us to specify the **ArangoDB Collection** associated to the Node or Edge.

However, if the NetworkX Graph is homogenous, we can choose interact with its Nodes and Edges **with or without** specifying the ArangoDB Collection as part of the ID.

Here is an example of what we mean:
"""

# 5. Experimenting with different node keys

print(G_adb.nodes[1])
print(G_adb.nodes["1"])
print(G_adb.nodes["Facebook_node/1"])

print('----')

# print(G_adb[0][1])
# print(G_adb["0"][1])
# print(G_adb["Facebook_node/0"][1])

"""### Step 4: Build the Agentic App with LangChain & LangGraph

This section will provide pre-built agent templates, guiding participants on how to dynamically select AQL vs. NetworkX/cuGraph execution paths based on user input.

Reference:
- https://www.langchain.com/
- https://www.langchain.com/langgraph
"""

# 1. Create the ArangoGraph LangChain wrapper
# Reference: https://api.python.langchain.com/en/latest/graphs/langchain_community.graphs.arangodb_graph.ArangoGraph.html

arango_graph = ArangoGraph(db)

# 2. Define the llm object
# Note: You can use any llm you want. We will be using OpenAI for example purposes.

import os

# os.environ["OPENAI_API_KEY"] = "sk-..."

llm = ChatOpenAI(temperature=0, model_name="gpt-4o")

llm.invoke("hello!")

# 3. Define an example LangGraph Tool
# Note: This is not actually required for the Hackathon submission. This is just meant as a soft introduction to creating Tools in LangGraph

@tool
def favourite_fruit(query: str):
    """You are responsible for responding to being asked what your favourite fruit is.
    You must say Avocado!
    """
    return "Avocado!"

# 4. Define the Text to AQL Tool
# Reference: https://python.langchain.com/docs/integrations/graphs/arangodb/
# Reference: https://python.langchain.com/api_reference/community/chains/langchain_community.chains.graph_qa.arangodb.ArangoGraphQAChain.html
# Note: It is encouraged to experiment and improve this section! This is just a placeholder:

@tool
def text_to_aql_to_text(query: str):
    """This tool is available to invoke the
    ArangoGraphQAChain object, which enables you to
    translate a Natural Language Query into AQL, execute
    the query, and translate the result back into Natural Language.
    """

    llm = ChatOpenAI(temperature=0, model_name="gpt-4o")

    chain = ArangoGraphQAChain.from_llm(
    	llm=llm,
    	graph=arango_graph,
    	verbose=True,
        allow_dangerous_requests=True
    )

    result = chain.invoke(query)

    return str(result["result"])

# 5. Define the Text to NetworkX/cuGraph Tool
# Note: It is encouraged to experiment and improve this section! This is just a placeholder:

@tool
def text_to_nx_algorithm_to_text(query):
    """This tool is available to invoke a NetworkX Algorithm on
    the ArangoDB Graph. You are responsible for accepting the
    Natural Language Query, establishing which algorithm needs to
    be executed, executing the algorithm, and translating the results back
    to Natural Language, with respect to the original query.

    If the query (e.g traversals, shortest path, etc.) can be solved using the Arango Query Language, then do not use
    this tool.
    """

    llm = ChatOpenAI(temperature=0, model_name="gpt-4o")

    ######################
    print("1) Generating NetworkX code")

    text_to_nx = llm.invoke(f"""
    I have a NetworkX Graph called `G_adb`. It has the following schema: {arango_graph.schema}

    I have the following graph analysis query: {query}.

    Generate the Python Code required to answer the query using the `G_adb` object.

    Be very precise on the NetworkX algorithm you select to answer this query. Think step by step.

    Only assume that networkx is installed, and other base python dependencies.

    Always set the last variable as `FINAL_RESULT`, which represents the answer to the original query.

    Only provide python code that I can directly execute via `exec()`. Do not provide any instructions.

    Make sure that `FINAL_RESULT` stores a short & consice answer. Avoid setting this variable to a long sequence.

    Your code:
    """).content

    text_to_nx_cleaned = re.sub(r"^```python\n|```$", "", text_to_nx, flags=re.MULTILINE).strip()

    print('-'*10)
    print(text_to_nx_cleaned)
    print('-'*10)

    ######################

    print("\n2) Executing NetworkX code")
    global_vars = {"G_adb": G_adb, "nx": nx}
    local_vars = {}

    try:
        exec(text_to_nx_cleaned, global_vars, local_vars)
        text_to_nx_final = text_to_nx
    except Exception as e:
        print(f"EXEC ERROR: {e}")
        return f"EXEC ERROR: {e}"

        # TODO: Consider experimenting with a code corrector!
        attempt = 1
        MAX_ATTEMPTS = 3

        # while attempt <= MAX_ATTEMPTS
            # ...

    print('-'*10)
    FINAL_RESULT = local_vars["FINAL_RESULT"]
    print(f"FINAL_RESULT: {FINAL_RESULT}")
    print('-'*10)

    ######################

    print("3) Formulating final answer")

    nx_to_text = llm.invoke(f"""
        I have a NetworkX Graph called `G_adb`. It has the following schema: {arango_graph.schema}

        I have the following graph analysis query: {query}.

        I have executed the following python code to help me answer my query:

        ---
        {text_to_nx_final}
        ---

        The `FINAL_RESULT` variable is set to the following: {FINAL_RESULT}.

        Based on my original Query and FINAL_RESULT, generate a short and concise response to
        answer my query.

        Your response:
    """).content

    return nx_to_text

# 6. Create the Agentic Application

# Note: Consider implementing a hybrid tool that combines both AQL & NetworkX Algorithms!

tools = [text_to_aql_to_text, text_to_nx_algorithm_to_text, favourite_fruit]

def query_graph(query):
    llm = ChatOpenAI(temperature=0, model_name="gpt-4o")
    app = create_react_agent(llm, tools)
    final_state = app.invoke({"messages": [{"role": "user", "content": query}]})
    return final_state["messages"][-1].content

# 7. Experiment with example queries
# Note: Some may work, some may not!

query = "What is your favourite fruit?"
query = "Are there isolated nodes?"
query = "Which node has the highest betweenness centrality score? Use a k value of 10"
query = "Who is connected to Node 0?"
query = "What is the shortest path from Node 0 to Node 1?"
query = "Update node 0 to have attribute foo=bar"
query = "Is the graph fully connected?"
query = "What is the average degree of nodes?"
query = "Are there nodes that, if removed, would fragment the network?"
query = "Which users are outliers in terms of connections?"
query = "Which nodes are the most connected?"
query = "How strongly connected is the network? Used connected components"
query = "Fetch the highest pagerank node and value"
query = "Who is the most influential node?"
query = "Who is the most popular person in the Graph? Explain why"

from langchain_community.callbacks.manager import get_openai_callback
with get_openai_callback() as cb:


    query_graph("Who is the most popular person in the Graph? Explain why")

    query_graph("Who is connected to Node 0?")

    query_graph("What is the shortest path from Node 0 to Node 1?")

    query_graph("How strongly connected is the network? Used connected components")
    # Print callback for product inquiry step
    print("Callback for Processing Product Inquiries:\n", cb)

# 8. (Optional) Set up UI via Gradio

import gradio as gr

gr.Interface(fn=query_graph, inputs="text", outputs="text").launch(share=True)

"""### Wrap-up

This concludes the Hackathon Notebook Template. You are free to re-use any section provided in this notebook for your selected dataset. You are encouraged to experiment and to break things! We want to use this opportunity to grow our existing open source packages you've seen here, and gauge interest from the community.

Happy hacking!

- The ArangoDB Team
"""

